原型模式：
    用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建
    对象的最佳方式。
    这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代建比较大时，
    则采用这种模式。例如：一个对象需要再一个高代价的数据库操作之后被创建。我们可以缓存该对象，
    在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。
介绍
    意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
    主要解决：在运行期建立和删除原型。
    何时使用：1、当一个系统应该独立于它的产品创建，构成和表示时。
             2、当要实例化的类是在运行时刻指定时，例如，通过动态加载。
             3、为了避免创建一个与产品类层次平行的工厂类层次时
             4、为了当一个类的实例只能有几个不同状态组合中的一种时。
    如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。
    关键代码：1.实现克隆操作，在Java中继承Cloneable,重写Clone()
             2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，
    应用实例：1、细胞分裂。2、java中的Object clone()方法。
    优点：1、性能提高。2、逃避构造函数的约束。
    缺点：1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定
            很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有玄幻结构的时候
          2、必须实现Cloneable接口
    使用场景：1、资源优化场景。
             2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。
             3、性能和安全要求的场景。
             4、通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式
             5、一个对象多个修改者的场景
             6、一个对象需要通过给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用
             原型模式拷贝多个对象供调用者使用
             7、在实际项目中，原型模式很少出现，一般是和工厂方法模式一起出现，通过clone的方法创建
             一个对象，然后由工厂方法提供给调用者。
    注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对
             象的。浅拷贝实现Cloneable,重写clone()，深拷贝是通过实现Serializable读取二进制流。
             
             
Clone方法：
    浅拷贝：实现Cloneable，重写clone(); clone出来的对象是不同的对象 即 == 比较为false
            但是其内部包含的类 则为同一对象 == 比较为true
    深拷贝：通过实现Serializable读取二进制流来拷贝  clone出来的对象及其内部的均为不同对象。   
    